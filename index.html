<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Реалистичная 3D-стрелялка (один файл)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    canvas { display: block; width: 100%; height: 100%; }
    /* Простой HUD */
    #hud {
      position: absolute;
      left: 10px; top: 10px;
      color: #0f0; font-family: monospace;
      text-shadow: 0 0 6px #000;
      z-index: 2;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="hud">Здоровье: 100 | Патроны: 30/120</div>
  <canvas id="glcanvas"></canvas>

  <script>
  // Весь код здесь: инициализация WebGL + простая сцена + управление + стрельба
  (() => {
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl', { antialias: true });
    if (!gl) {
      alert('WebGL не поддерживается в этом браузере.');
      return;
    }

    // Простая шейдерная программа (вершинный и фрагментный шейдеры)
    const vsSrc = `
      attribute vec3 aPos;
      attribute vec3 aColor;
      uniform mat4 uProjView;
      varying vec3 vColor;
      void main() {
        gl_Position = uProjView * vec4(aPos, 1.0);
        vColor = aColor;
      }
    `;
    const fsSrc = `
      precision mediump float;
      varying vec3 vColor;
      void main() {
        gl_FragColor = vec4(vColor, 1.0);
      }
    `;
    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
    const vs = compileShader(gl.VERTEX_SHADER, vsSrc);
    const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc);
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
      return;
    }
    gl.useProgram(program);

    // Простая геометрия: ground plane и пули
    // Создаём простой квадрат (земля) и куб (оружие-бортик как HUD-объект)
    function createBuffer(data) {
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
      return buf;
    }
    // Цвета
    function color(r,g,b){ return [r/255, g/255, b/255]; }

    // Земля (плоскость, маленькая)
    const groundSize = 50;
    const groundVerts = [
      // x, y, z,  r,g,b
      -groundSize, 0, -groundSize, ...color(0,0,0),
       groundSize, 0, -groundSize, ...color(0,0,0),
      -groundSize, 0,  groundSize, ...color(0.1,0.1,0.1),
       groundSize, 0,  groundSize, ...color(0.1,0.1,0.1),
    ];
    // у нас будет простой квадрат два треугольника, зададим через TRIANGLE_STRIP
    const groundBuf = createBuffer(groundVerts);

    // Пули (мелкие кубики)
    function bulletVerts(x,y,z, r=0.04, colorVec=[1,0,0]){
      // простой кубик 8 вершин упрощённо (но для скорости сделаем один треугольник как пиксель)
      // здесь просто точка-вершина= не будет работать без объёмной геометрии.
      // Чтобы держать всё в одном файле и проще, используем маленький пиксельный квадрат как спрайт через 2D-элемент.
      return null;
    }

    // Но чтобы не усложнять, сделаем "пульку" как маленькая точечная точка через gl.POINTS
    const pointBuffer = createBuffer([0,0,0,  1,0,0]); // позиция + цвет (потребуются атрибуты)
    // Установим атрибуты
    const aPos = gl.getAttribLocation(program, 'aPos');
    const aColor = gl.getAttribLocation(program, 'aColor');
    const uProjView = gl.getUniformLocation(program, 'uProjView');

    // Установка структуры: у нас два вершинных атрибута
    gl.enableVertexAttribArray(aPos);
    gl.enableVertexAttribArray(aColor);

    // Простая матрица проекции-последовательности (Perspective)
    function createPerspective(aspect, fov, near, far){
      const f = 1.0 / Math.tan((fov * Math.PI) / 360);
      const M = new Float32Array(16);
      M[0] = f / aspect;
      M[5] = f;
      M[10] = (far + near) / (near - far);
      M[11] = -1;
      M[14] = (2 * far * near) / (near - far);
      M[15] = 0;
      return M;
    }
    function lookAt(eye, target, up){
      const z = normalize(sub(eye, target));
      const x = normalize(cross(up, z));
      const y = cross(z, x);
      const M = new Float32Array(16);
      M[0]=x[0]; M[4]=x[1]; M[8]=x[2]; M[12]=-dot(x, eye);
      M[1]=y[0]; M[5]=y[1]; M[9]=y[2]; M[13]=-dot(y, eye);
      M[2]=z[0]; M[6]=z[1]; M[10]=z[2]; M[14]=-dot(z, eye);
      M[3]=0; M[7]=0; M[11]=0; M[15]=1;
      return M;
    }
    function mul(a,b){
      const out = new Float32Array(16);
      for(let i=0;i<4;i++)
        for(let j=0;j<4;j++){
          out[i*4+j]=0;
          for(let k=0;k<4;k++) out[i*4+j]+=a[i*4+k]*b[k*4+j];
        }
      return out;
    }
    function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
    function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
    function sub(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
    function normalize(v){
      const len = Math.hypot(v[0], v[1], v[2]) || 1;
      return [v[0]/len, v[1]/len, v[2]/len];
    }

    // Простой ввод: шейдеры ждут матрицу uProjView
    const fov = 60;
    const aspect = innerWidth / innerHeight;
    let proj = createPerspective(aspect, fov, 0.1, 100);
    // Камера: положение и направление
    let camPos = [0, 1.6, 5];
    let camRotX = 0; // по вертикали
    let camDir = [0,0,-1];
    const keys = {};
    window.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

    // Управление курсором (курсор LOCK)
    let pointerLocked = false;
    canvas.addEventListener('click', ()=> {
      canvas.requestPointerLock();
    });
    document.addEventListener('pointerlockchange', ()=> {
      pointerLocked = document.pointerLockElement === canvas;
    });

    // Реалистичная отдача: простая задержка между выстрелами
    let lastShot = 0;
    let ammo = 30;
    let maxAmmo = 120;
    let health = 100;

    // Стрелять по клику мыши (левая кнопка)
    window.addEventListener('mousedown', (e)=> {
      if (e.button === 0 && pointerLocked) shoot();
    });

    function shoot() {
      const now = performance.now();
      if (now - lastShot < 200) return; // перезарядка 0.2с
      if (ammo <= 0) return;
      ammo--;
      lastShot = now;
      // Добавим простую трассировку в виде отрисовки линии на экране через 2D overlay? (упрощенно пропустим)
      // Можно эмулировать попадание в простой меш в сцене, но здесь держим минимально: просто создаём